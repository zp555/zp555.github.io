
 <!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
  
    <title>Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="John Doe">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/%02.css">
<link rel="stylesheet" href="/.css">

<meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Hexo" title="Hexo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Hexo">Hexo</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:example.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2021/07/19/vue/" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="John Doe" target="_blank" itemprop="author">John Doe</a>
		
  <p class="article-time">
    <time datetime="2021-07-19T06:18:05.664Z" itemprop="datePublished"> Published 2021-07-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <hr>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><h4 id="1-MVC-和-MVVM-区别"><a href="#1-MVC-和-MVVM-区别" class="headerlink" title="1 MVC 和 MVVM 区别"></a>1 MVC 和 MVVM 区别</h4><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><p>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范</p>
<ul>
<li><p>Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据</p>
</li>
<li><p>View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的</p>
</li>
<li><p>Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据</p>
<p><img src="D:\资料\12---实训\案例\资料图\微信图片_20210524103232.jpg"></p>
</li>
</ul>
<p>MVC 的思想：一句话描述就是 Controller 负责将 Model 的数据用 View 显示出来，换句话说就是在 Controller 里面把 Model 的数据赋值给 View。</p>
<h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><p>MVVM 新增了 VM 类</p>
<ul>
<li><p>ViewModel 层：做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</p>
<p><img src="D:\资料\12---实训\案例\资料图\微信图片_20210524103309.jpg"></p>
</li>
</ul>
<p>MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</p>
<p>整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：Vue 并没有完全遵循 MVVM 的思想 这一点官网自己也有说明</span><br></pre></td></tr></table></figure>

<p><img src="D:\资料\12---实训\案例\资料图\微信图片_20210524103351.jpg"></p>
<p>那么问题来了 为什么官方要说 Vue 没有完全遵循 MVVM 思想呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 提供了 $refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。</span><br></pre></td></tr></table></figure>

<h4 id="2-为什么-data-是一个函数"><a href="#2-为什么-data-是一个函数" class="headerlink" title="2 为什么 data 是一个函数"></a>2 为什么 data 是一个函数</h4><p>组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果</p>
<h4 id="3-Vue-组件通讯有哪几种方式"><a href="#3-Vue-组件通讯有哪几种方式" class="headerlink" title="3 Vue 组件通讯有哪几种方式"></a>3 Vue 组件通讯有哪几种方式</h4><ol>
<li>props 和 emit父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过emit 触发事件来做到的</li>
<li>parent,children 获取当前组件的父组件和当前组件的子组件</li>
<li>attrs和listeners A-&gt;B-&gt;C。Vue 2.4 开始提供了attrs 和listeners 来解决这个问题</li>
<li>父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)</li>
<li>$refs 获取组件实例</li>
<li>envetBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式</li>
<li>vuex 状态管理</li>
</ol>
<h4 id="4-Vue-的生命周期方法有哪些-一般在哪一步发请求"><a href="#4-Vue-的生命周期方法有哪些-一般在哪一步发请求" class="headerlink" title="4 Vue 的生命周期方法有哪些 一般在哪一步发请求"></a>4 Vue 的生命周期方法有哪些 一般在哪一步发请求</h4><p><strong>「beforeCreate」</strong> 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问</p>
<p><strong>「created」</strong> 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有 如果非要想与进行交互，可以通过nextTick 来访问 Dom</p>
<p><strong>「beforeMount」</strong> 在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<p><strong>「mounted」</strong> 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点</p>
<p><strong>「beforeUpdate」</strong> 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p>
<p><strong>「updated」</strong> 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。</p>
<p><strong>「beforeDestroy」</strong> 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。</p>
<p><strong>「destroyed」</strong> Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p>
<p><strong>「activated」</strong> keep-alive 专属，组件被激活时调用</p>
<p><strong>「deactivated」</strong> keep-alive 专属，组件被销毁时调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">异步请求在哪一步发起？</span><br></pre></td></tr></table></figure>

<p>可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p>
<p>如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面  loading 时间；</li>
<li>ssr  不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>
<h4 id="5-v-if-和-v-show-的区别"><a href="#5-v-if-和-v-show-的区别" class="headerlink" title="5 v-if 和 v-show 的区别"></a>5 v-if 和 v-show 的区别</h4><p>v-if 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点。</p>
<p>v-show 会被编译成指令，条件不满足时控制样式将对应节点隐藏 （display:none）</p>
<p><strong>「使用场景」</strong></p>
<p>v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景</p>
<p>v-show 适用于需要非常频繁切换条件的场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扩展补充：display:none、visibility:hidden 和 opacity:0 之间的区别？</span><br></pre></td></tr></table></figure>

<p><img src="D:\资料\12---实训\案例\资料图\微信图片_20210524103139.jpg"></p>
<h4 id="6-说说-vue-内置指令"><a href="#6-说说-vue-内置指令" class="headerlink" title="6 说说 vue 内置指令"></a>6 说说 vue 内置指令</h4><p><img src="D:\资料\12---实训\案例\资料图\微信图片_20210524103430.jpg"></p>
<h4 id="7-怎样理解-Vue-的单向数据流"><a href="#7-怎样理解-Vue-的单向数据流" class="headerlink" title="7 怎样理解 Vue 的单向数据流"></a>7 怎样理解 Vue 的单向数据流</h4><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告</span><br></pre></td></tr></table></figure>

<p>如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用 $emit 通知父组件去修改</p>
<h4 id="8-computed-和-watch-的区别和运用的场景"><a href="#8-computed-和-watch-的区别和运用的场景" class="headerlink" title="8 computed 和 watch 的区别和运用的场景"></a>8 computed 和 watch 的区别和运用的场景</h4><p>computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，它可以设置 getter 和 setter。</p>
<p>watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p>
<p>计算属性一般用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑</p>
<h4 id="9-v-if-与-v-for-为什么不建议一起使用"><a href="#9-v-if-与-v-for-为什么不建议一起使用" class="headerlink" title="9 v-if 与 v-for 为什么不建议一起使用"></a>9 v-if 与 v-for 为什么不建议一起使用</h4><p>v-for 和 v-if 不要在同一个标签中使用,因为解析时先解析 v-for 再解析 v-if。如果遇到需要同时使用时可以考虑写成计算属性的方式。</p>
<h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><h4 id="10-Vue2-0-响应式数据的原理"><a href="#10-Vue2-0-响应式数据的原理" class="headerlink" title="10 Vue2.0 响应式数据的原理"></a>10 Vue2.0 响应式数据的原理</h4><p>整体思路是数据劫持+观察者模式</p>
<p>对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。</p>
<p>相关代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Observer &#123;</span><br><span class="line">  // 观测值</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    this.walk(value);</span><br><span class="line">  &#125;</span><br><span class="line">  walk(data) &#123;</span><br><span class="line">    // 对象上的所有属性依次进行观测</span><br><span class="line">    let keys = Object.keys(data);</span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      let key = keys[i];</span><br><span class="line">      let value = data[key];</span><br><span class="line">      defineReactive(data, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span><br><span class="line">function defineReactive(data, key, value) &#123;</span><br><span class="line">  observe(value); // 递归关键</span><br><span class="line">  // --如果value还是一个对象会继续走一遍odefineReactive 层层遍历一直到value不是对象才停止</span><br><span class="line">  //   思考？如果Vue数据嵌套层级过深 &gt;&gt;性能会受影响</span><br><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      console.log(&quot;获取值&quot;);</span><br><span class="line"></span><br><span class="line">      //需要做依赖收集过程 这里代码没写出来</span><br><span class="line">      return value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">      if (newValue === value) return;</span><br><span class="line">      console.log(&quot;设置值&quot;);</span><br><span class="line">      //需要做派发更新过程 这里代码没写出来</span><br><span class="line">      value = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">export function observe(value) &#123;</span><br><span class="line">  // 如果传过来的是对象或者数组 进行属性劫持</span><br><span class="line">  if (</span><br><span class="line">    Object.prototype.toString.call(value) === &quot;[object Object]&quot; ||</span><br><span class="line">    Array.isArray(value)</span><br><span class="line">  ) &#123;</span><br><span class="line">    return new Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-Vue-如何检测数组变化"><a href="#11-Vue-如何检测数组变化" class="headerlink" title="11 Vue 如何检测数组变化"></a>11 Vue 如何检测数组变化</h4><p>数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择对 7 种数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写(AOP 切片思想)</p>
<p>所以在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新</p>
<p>相关代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// src/obserber/array.js</span><br><span class="line">// 先保留数组原型</span><br><span class="line">const arrayProto = Array.prototype;</span><br><span class="line">// 然后将arrayMethods继承自数组原型</span><br><span class="line">// 这里是面向切片编程思想（AOP）--不破坏封装的前提下，动态的扩展功能</span><br><span class="line">export const arrayMethods = Object.create(arrayProto);</span><br><span class="line">let methodsToPatch = [</span><br><span class="line">  &quot;push&quot;,</span><br><span class="line">  &quot;pop&quot;,</span><br><span class="line">  &quot;shift&quot;,</span><br><span class="line">  &quot;unshift&quot;,</span><br><span class="line">  &quot;splice&quot;,</span><br><span class="line">  &quot;reverse&quot;,</span><br><span class="line">  &quot;sort&quot;,</span><br><span class="line">];</span><br><span class="line">methodsToPatch.forEach((method) =&gt; &#123;</span><br><span class="line">  arrayMethods[method] = function (...args) &#123;</span><br><span class="line">    //   这里保留原型方法的执行结果</span><br><span class="line">    const result = arrayProto[method].apply(this, args);</span><br><span class="line">    // 这句话是关键</span><br><span class="line">    // this代表的就是数据本身 比如数据是&#123;a:[1,2,3]&#125; 那么我们使用a.push(4)  this就是a  ob就是a.__ob__ 这个属性就是上段代码增加的 代表的是该数据已经被响应式观察过了指向Observer实例</span><br><span class="line">    const ob = this.__ob__;</span><br><span class="line"></span><br><span class="line">    // 这里的标志就是代表数组有新增操作</span><br><span class="line">    let inserted;</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      case &quot;push&quot;:</span><br><span class="line">      case &quot;unshift&quot;:</span><br><span class="line">        inserted = args;</span><br><span class="line">        break;</span><br><span class="line">      case &quot;splice&quot;:</span><br><span class="line">        inserted = args.slice(2);</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果有新增的元素 inserted是一个数组 调用Observer实例的observeArray对数组每一项进行观测</span><br><span class="line">    if (inserted) ob.observeArray(inserted);</span><br><span class="line">    // 之后咱们还可以在这里检测到数组改变了之后从而触发视图更新的操作--后续源码会揭晓</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="12-vue3-0-用过吗-了解多少"><a href="#12-vue3-0-用过吗-了解多少" class="headerlink" title="12 vue3.0 用过吗 了解多少"></a>12 vue3.0 用过吗 了解多少</h4><ul>
<li>响应式原理的改变 Vue3.x 使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty</li>
<li>组件选项声明方式 Vue3.x 使用 Composition API setup 是 Vue3.x 新增的一个选项， 他是组件内使用 Composition API 的入口。</li>
<li>模板语法变化 slot 具名插槽语法 自定义指令 v-model 升级</li>
<li>其它方面的更改 Suspense 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。基于 treeshaking 优化，提供了更多的内置功能。</li>
</ul>
<h4 id="13-Vue3-0-和-2-0-的响应式原理区别"><a href="#13-Vue3-0-和-2-0-的响应式原理区别" class="headerlink" title="13 Vue3.0 和 2.0 的响应式原理区别"></a>13 Vue3.0 和 2.0 的响应式原理区别</h4><p>Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。</p>
<p>相关代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mutableHandlers &#125; from &quot;./baseHandlers&quot;; // 代理相关逻辑</span><br><span class="line">import &#123; isObject &#125; from &quot;./util&quot;; // 工具方法</span><br><span class="line"></span><br><span class="line">export function reactive(target) &#123;</span><br><span class="line">  // 根据不同参数创建不同响应式对象</span><br><span class="line">  return createReactiveObject(target, mutableHandlers);</span><br><span class="line">&#125;</span><br><span class="line">function createReactiveObject(target, baseHandler) &#123;</span><br><span class="line">  if (!isObject(target)) &#123;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line">  const observed = new Proxy(target, baseHandler);</span><br><span class="line">  return observed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const get = createGetter();</span><br><span class="line">const set = createSetter();</span><br><span class="line"></span><br><span class="line">function createGetter() &#123;</span><br><span class="line">  return function get(target, key, receiver) &#123;</span><br><span class="line">    // 对获取的值进行放射</span><br><span class="line">    const res = Reflect.get(target, key, receiver);</span><br><span class="line">    console.log(&quot;属性获取&quot;, key);</span><br><span class="line">    if (isObject(res)) &#123;</span><br><span class="line">      // 如果获取的值是对象类型，则返回当前对象的代理对象</span><br><span class="line">      return reactive(res);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function createSetter() &#123;</span><br><span class="line">  return function set(target, key, value, receiver) &#123;</span><br><span class="line">    const oldValue = target[key];</span><br><span class="line">    const hadKey = hasOwn(target, key);</span><br><span class="line">    const result = Reflect.set(target, key, value, receiver);</span><br><span class="line">    if (!hadKey) &#123;</span><br><span class="line">      console.log(&quot;属性新增&quot;, key, value);</span><br><span class="line">    &#125; else if (hasChanged(value, oldValue)) &#123;</span><br><span class="line">      console.log(&quot;属性值被修改&quot;, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">export const mutableHandlers = &#123;</span><br><span class="line">  get, // 当获取属性时调用此方法</span><br><span class="line">  set, // 当修改属性时调用此方法</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="14-Vue-的父子组件生命周期钩子函数执行顺序"><a href="#14-Vue-的父子组件生命周期钩子函数执行顺序" class="headerlink" title="14 Vue 的父子组件生命周期钩子函数执行顺序"></a>14 Vue 的父子组件生命周期钩子函数执行顺序</h4><ul>
<li>加载渲染过程</li>
</ul>
<p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</p>
<ul>
<li>子组件更新过程</li>
</ul>
<p>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p>
<ul>
<li>父组件更新过程</li>
</ul>
<p>父 beforeUpdate-&gt;父 updated</p>
<ul>
<li>销毁过程</li>
</ul>
<p>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p>
<h4 id="15-虚拟-DOM-是什么-有什么优缺点"><a href="#15-虚拟-DOM-是什么-有什么优缺点" class="headerlink" title="15 虚拟 DOM 是什么 有什么优缺点"></a>15 虚拟 DOM 是什么 有什么优缺点</h4><p>由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。这就是虚拟 Dom 的产生原因。Vue2 的 Virtual DOM 借鉴了开源库 snabbdom 的实现。Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点，是对真实 DOM 的一层抽象。</p>
<p><strong>「优点：」</strong></p>
<ol>
<li>保证性能下限：框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li>
<li>无需手动操作 DOM：我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
<li>跨平台：虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li>
</ol>
<p><strong>「缺点:」</strong></p>
<ol>
<li>无法进行极致优化：虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li>
<li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。</li>
</ol>
<h4 id="16-v-model-原理"><a href="#16-v-model-原理" class="headerlink" title="16 v-model 原理"></a>16 v-model 原理</h4><p>v-model 只是语法糖而已</p>
<p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value property 和 input 事件；</li>
<li>checkbox 和 radio 使用 checked property 和 change 事件；</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意:对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。</span><br></pre></td></tr></table></figure>

<p>在普通标签上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;sth&quot; /&gt;  //这一行等于下一行</span><br><span class="line">   &lt;input v-bind:value=&quot;sth&quot; v-on:input=&quot;sth = $event.target.value&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>在组件上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currentcy-input&gt;</span><br><span class="line">&lt;!--上行代码是下行的语法糖</span><br><span class="line"> &lt;currency-input :value=&quot;price&quot; @input=&quot;price = arguments[0]&quot;&gt;&lt;/currency-input&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件定义 --&gt;</span><br><span class="line">Vue.component(&#x27;currency-input&#x27;, &#123;</span><br><span class="line"> template: `</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">   &lt;input</span><br><span class="line">    ref=&quot;input&quot;</span><br><span class="line">    :value=&quot;value&quot;</span><br><span class="line">    @input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">   &gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line"> `,</span><br><span class="line"> props: [&#x27;value&#x27;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="17-v-for-为什么要加-key"><a href="#17-v-for-为什么要加-key" class="headerlink" title="17 v-for 为什么要加 key"></a>17 v-for 为什么要加 key</h4><p>如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p>
<p><strong>「更准确」</strong>：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。</p>
<p><strong>「更快速」</strong>：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</p>
<p>相关代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 判断两个vnode的标签和key是否相同 如果相同 就可以认为是同一节点就地复用</span><br><span class="line">function isSameVnode(oldVnode, newVnode) &#123;</span><br><span class="line">  return oldVnode.tag === newVnode.tag &amp;&amp; oldVnode.key === newVnode.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据key来创建老的儿子的index映射表  类似 &#123;&#x27;a&#x27;:0,&#x27;b&#x27;:1&#125; 代表key为&#x27;a&#x27;的节点在第一个位置 key为&#x27;b&#x27;的节点在第二个位置</span><br><span class="line">function makeIndexByKey(children) &#123;</span><br><span class="line">  let map = &#123;&#125;;</span><br><span class="line">  children.forEach((item, index) =&gt; &#123;</span><br><span class="line">    map[item.key] = index;</span><br><span class="line">  &#125;);</span><br><span class="line">  return map;</span><br><span class="line">&#125;</span><br><span class="line">// 生成的映射表</span><br><span class="line">let map = makeIndexByKey(oldCh);</span><br></pre></td></tr></table></figure>

<h4 id="18-Vue-事件绑定原理"><a href="#18-Vue-事件绑定原理" class="headerlink" title="18 Vue 事件绑定原理"></a>18 Vue 事件绑定原理</h4><p>原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过 Vue 自定义的 $on 实现的。如果要在组件上使用原生事件，需要加.native 修饰符，这样就相当于在父组件中把子组件当做普通 html 标签，然后加上原生事件。</p>
<p>on、emit 是基于发布订阅模式的，维护一个事件中心，on 的时候将事件按名称存在事件中心里，称之为订阅者，然后 emit 将对应的事件进行发布，去执行事件中心里的对应的监听器</p>
<h4 id="19-vue-router-路由钩子函数是什么-执行顺序是什么"><a href="#19-vue-router-路由钩子函数是什么-执行顺序是什么" class="headerlink" title="19 vue-router 路由钩子函数是什么 执行顺序是什么"></a>19 vue-router 路由钩子函数是什么 执行顺序是什么</h4><p>路由钩子的执行流程, 钩子函数种类有:全局守卫、路由守卫、组件守卫</p>
<p><strong>「完整的导航解析流程:」</strong></p>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用 beforeRouteLeave 守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>
</ol>
<h4 id="20-vue-router-动态路由是什么-有什么问题"><a href="#20-vue-router-动态路由是什么-有什么问题" class="headerlink" title="20 vue-router 动态路由是什么 有什么问题"></a>20 vue-router 动态路由是什么 有什么问题</h4><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &quot;&lt;div&gt;User&lt;/div&gt;&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    // 动态路径参数 以冒号开头</span><br><span class="line">    &#123; path: &quot;/user/:id&quot;, component: User &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>问题:vue-router 组件复用导致路由参数失效怎么办？</p>
<p>解决方法：</p>
<p>1.通过 watch 监听路由参数再发请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123; //通过watch来监听路由变化</span><br><span class="line"></span><br><span class="line"> &quot;$route&quot;: function()&#123;</span><br><span class="line"> this.getData(this.$route.params.xxx);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.用 :key 来阻止“复用”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :key=&quot;$route.fullPath&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="21-谈一下对-vuex-的个人理解"><a href="#21-谈一下对-vuex-的个人理解" class="headerlink" title="21 谈一下对 vuex 的个人理解"></a>21 谈一下对 vuex 的个人理解</h4><p>vuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存等。（无法持久化、内部核心原理是通过创造一个全局实例 new Vue）</p>
<p><img src="D:\资料\12---实训\案例\资料图\微信图片_20210524105103.jpg"></p>
<p>主要包括以下几个模块：</p>
<ul>
<li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li>
<li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
<li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li>
<li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li>
<li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li>
</ul>
<h4 id="22-Vuex-页面刷新数据丢失怎么解决"><a href="#22-Vuex-页面刷新数据丢失怎么解决" class="headerlink" title="22 Vuex 页面刷新数据丢失怎么解决"></a>22 Vuex 页面刷新数据丢失怎么解决</h4><p>需要做 vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件</p>
<p>推荐使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中</p>
<h4 id="23-Vuex-为什么要分模块并且加命名空间"><a href="#23-Vuex-为什么要分模块并且加命名空间" class="headerlink" title="23 Vuex 为什么要分模块并且加命名空间"></a>23 Vuex 为什么要分模块并且加命名空间</h4><p><strong>「模块」</strong>:由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。</p>
<p><strong>「命名空间」</strong>：默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p>
<h4 id="24-使用过-Vue-SSR-吗？说说-SSR"><a href="#24-使用过-Vue-SSR-吗？说说-SSR" class="headerlink" title="24 使用过 Vue SSR 吗？说说 SSR"></a>24 使用过 Vue SSR 吗？说说 SSR</h4><p>SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。</p>
<p><strong>「优点：」</strong></p>
<p>SSR 有着更好的 SEO、并且首屏加载速度更快</p>
<p><strong>「缺点：」</strong> 开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。</p>
<p>服务器会有更大的负载需求</p>
<h4 id="25-vue-中使用了哪些设计模式"><a href="#25-vue-中使用了哪些设计模式" class="headerlink" title="25 vue 中使用了哪些设计模式"></a>25 vue 中使用了哪些设计模式</h4><p>1.工厂模式 - 传入参数即可创建实例</p>
<p>虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode</p>
<p>2.单例模式 - 整个程序有且仅有一个实例</p>
<p>vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉</p>
<p>3.发布-订阅模式 (vue 事件机制)</p>
<p>4.观察者模式 (响应式数据原理)</p>
<p>5.装饰模式: (@装饰器的用法)</p>
<p>6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略</p>
<h4 id="26-你都做过哪些-Vue-的性能优化"><a href="#26-你都做过哪些-Vue-的性能优化" class="headerlink" title="26 你都做过哪些 Vue 的性能优化"></a>26 你都做过哪些 Vue 的性能优化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里只列举针对 Vue 的性能优化 整个项目的性能优化是一个大工程 </span><br></pre></td></tr></table></figure>

<ul>
<li>对象层级不要过深，否则性能就会差</li>
<li>不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）</li>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch 区分使用场景</li>
<li>v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if</li>
<li>大数据列表和表格性能优化-虚拟列表/虚拟表格</li>
<li>防止内部泄漏，组件销毁后把全局变量和事件销毁</li>
<li>图片懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>适当采用 keep-alive 缓存组件</li>
<li>防抖、节流运用</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><h4 id="27-Vue-mixin-的使用场景和原理"><a href="#27-Vue-mixin-的使用场景和原理" class="headerlink" title="27 Vue.mixin 的使用场景和原理"></a>27 Vue.mixin 的使用场景和原理</h4><p>在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过 Vue 的 mixin 功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p>
<p>相关代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">let callbacks = [];</span><br><span class="line">let pending = false;</span><br><span class="line">function flushCallbacks() &#123;</span><br><span class="line">  pending = false; //把标志还原为false</span><br><span class="line">  // 依次执行回调</span><br><span class="line">  for (let i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">    callbacks[i]( &quot;i&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let timerFunc; //定义异步方法  采用优雅降级</span><br><span class="line">if (typeof Promise !== &quot;undefined&quot;) &#123;</span><br><span class="line">  // 如果支持promise</span><br><span class="line">  const p = Promise.resolve();</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else if (typeof MutationObserver !== &quot;undefined&quot;) &#123;</span><br><span class="line">  // MutationObserver 主要是监听dom变化 也是一个异步方法</span><br><span class="line">  let counter = 1;</span><br><span class="line">  const observer = new MutationObserver(flushCallbacks);</span><br><span class="line">  const textNode = document.createTextNode(String(counter));</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: true,</span><br><span class="line">  &#125;);</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    counter = (counter + 1) % 2;</span><br><span class="line">    textNode.data = String(counter);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else if (typeof setImmediate !== &quot;undefined&quot;) &#123;</span><br><span class="line">  // 如果前面都不支持 判断setImmediate</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 最后降级采用setTimeout</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function nextTick(cb) &#123;</span><br><span class="line">  // 除了渲染watcher  还有用户自己手动调用的nextTick 一起被收集到数组</span><br><span class="line">  callbacks.push(cb);</span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    // 如果多次调用nextTick  只会执行一次异步 等异步队列清空之后再把标志变为false</span><br><span class="line">    pending = true;</span><br><span class="line">    timerFunc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="29-keep-alive-使用场景和原理"><a href="#29-keep-alive-使用场景和原理" class="headerlink" title="29 keep-alive 使用场景和原理"></a>29 keep-alive 使用场景和原理</h4><p>keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p>
<ul>
<li>常用的两个属性 include/exclude，允许组件有条件的进行缓存。</li>
<li>两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。</li>
<li>keep-alive 的中还运用了 LRU(最近最少使用) 算法，选择最近最久未使用的组件予以淘汰。</li>
</ul>
<p>相关代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &quot;keep-alive&quot;,</span><br><span class="line">  abstract: true, //抽象组件</span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes, //要缓存的组件</span><br><span class="line">    exclude: patternTypes, //要排除的组件</span><br><span class="line">    max: [String, Number], //最大缓存数</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created() &#123;</span><br><span class="line">    this.cache = Object.create(null); //缓存对象  &#123;a:vNode,b:vNode&#125;</span><br><span class="line">    this.keys = []; //缓存组件的key集合 [a,b]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    for (const key in this.cache) &#123;</span><br><span class="line">      pruneCacheEntry(this.cache, key, this.keys);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    //动态监听include  exclude</span><br><span class="line">    this.$watch(&quot;include&quot;, (val) =&gt; &#123;</span><br><span class="line">      pruneCache(this, (name) =&gt; matches(val, name));</span><br><span class="line">    &#125;);</span><br><span class="line">    this.$watch(&quot;exclude&quot;, (val) =&gt; &#123;</span><br><span class="line">      pruneCache(this, (name) =&gt; !matches(val, name));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const slot = this.$slots.default; //获取包裹的插槽默认值</span><br><span class="line">    const vnode: VNode = getFirstComponentChild(slot); //获取第一个子组件</span><br><span class="line">    const componentOptions: ?VNodeComponentOptions =</span><br><span class="line">      vnode &amp;&amp; vnode.componentOptions;</span><br><span class="line">    if (componentOptions) &#123;</span><br><span class="line">      // check pattern</span><br><span class="line">      const name: ?string = getComponentName(componentOptions);</span><br><span class="line">      const &#123; include, exclude &#125; = this;</span><br><span class="line">      // 不走缓存</span><br><span class="line">      if (</span><br><span class="line">        // not included  不包含</span><br><span class="line">        (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">        // excluded  排除里面</span><br><span class="line">        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">      ) &#123;</span><br><span class="line">        //返回虚拟节点</span><br><span class="line">        return vnode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const &#123; cache, keys &#125; = this;</span><br><span class="line">      const key: ?string =</span><br><span class="line">        vnode.key == null</span><br><span class="line">          ? // same constructor may get registered as different local components</span><br><span class="line">            // so cid alone is not enough (#3269)</span><br><span class="line">            componentOptions.Ctor.cid +</span><br><span class="line">            (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &quot;&quot;)</span><br><span class="line">          : vnode.key;</span><br><span class="line">      if (cache[key]) &#123;</span><br><span class="line">        //通过key 找到缓存 获取实例</span><br><span class="line">        vnode.componentInstance = cache[key].componentInstance;</span><br><span class="line">        // make current key freshest</span><br><span class="line">        remove(keys, key); //通过LRU算法把数组里面的key删掉</span><br><span class="line">        keys.push(key); //把它放在数组末尾</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        cache[key] = vnode; //没找到就换存下来</span><br><span class="line">        keys.push(key); //把它放在数组末尾</span><br><span class="line">        // prune oldest entry  //如果超过最大值就把数组第0项删掉</span><br><span class="line">        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;</span><br><span class="line">          pruneCacheEntry(cache, keys[0], keys, this._vnode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      vnode.data.keepAlive = true; //标记虚拟节点已经被缓存</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回虚拟节点</span><br><span class="line">    return vnode || (slot &amp;&amp; slot[0]);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扩展补充：LRU 算法是什么？</span><br></pre></td></tr></table></figure>

<p><img src="D:\资料\12---实训\案例\资料图\微信图片_20210524105413.jpg"></p>
<p>LRU 的核心思想是如果数据最近被访问过，那么将来被访问的几率也更高，所以我们将命中缓存的组件 key 重新插入到 this.keys 的尾部，这样一来，this.keys 中越往头部的数据即将来被访问几率越低，所以当缓存数量达到最大值时，我们就删除将来被访问几率最低的数据，即 this.keys 中第一个缓存的组件。</p>
<h4 id="30-Vue-set-方法原理"><a href="#30-Vue-set-方法原理" class="headerlink" title="30 Vue.set 方法原理"></a>30 Vue.set 方法原理</h4><p>了解 Vue 响应式原理的同学都知道在两种情况下修改数据 Vue 是不会触发视图更新的</p>
<p>1.在实例创建之后添加新的属性到实例上（给响应式对象新增属性）</p>
<p>2.直接更改数组下标来修改数组的值</p>
<p>Vue.set 或者说是 $set 原理如下</p>
<p>因为响应式数据 我们给对象和数组本身都增加了__ob__属性，代表的是 Observer 实例。当给对象新增不存在的属性 首先会把新的属性进行响应式跟踪 然后会触发对象__ob__的 dep 收集到的 watcher 去更新，当修改数组索引时我们调用数组本身的 splice 方法去更新数组</p>
<p>相关代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export function set(target: Array | Object, key: any, val: any): any &#123;</span><br><span class="line">  // 如果是数组 调用我们重写的splice方法 (这样可以更新视图)</span><br><span class="line">  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = Math.max(target.length, key);</span><br><span class="line">    target.splice(key, 1, val);</span><br><span class="line">    return val;</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果是对象本身的属性，则直接添加即可</span><br><span class="line">  if (key in target &amp;&amp; !(key in Object.prototype)) &#123;</span><br><span class="line">    target[key] = val;</span><br><span class="line">    return val;</span><br><span class="line">  &#125;</span><br><span class="line">  const ob = (target: any).__ob__;</span><br><span class="line"></span><br><span class="line">  // 如果不是响应式的也不需要将其定义成响应式属性</span><br><span class="line">  if (!ob) &#123;</span><br><span class="line">    target[key] = val;</span><br><span class="line">    return val;</span><br><span class="line">  &#125;</span><br><span class="line">  // 将属性定义成响应式的</span><br><span class="line">  defineReactive(ob.value, key, val);</span><br><span class="line">  // 通知视图更新</span><br><span class="line">  ob.dep.notify();</span><br><span class="line">  return val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="31-Vue-extend-作用和原理"><a href="#31-Vue-extend-作用和原理" class="headerlink" title="31 Vue.extend 作用和原理"></a>31 Vue.extend 作用和原理</h4><p>官方解释：Vue.extend 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p>
<p>其实就是一个子类构造器 是 Vue 组件的核心 api 实现思路就是使用原型继承的方法返回了 Vue 的子类 并且利用 mergeOptions 把传入组件的 options 和父类的 options 进行了合并</p>
<p>相关代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default function initExtend(Vue) &#123;</span><br><span class="line">  let cid = 0; //组件的唯一标识</span><br><span class="line">  // 创建子类继承Vue父类 便于属性扩展</span><br><span class="line">  Vue.extend = function (extendOptions) &#123;</span><br><span class="line">    // 创建子类的构造函数 并且调用初始化方法</span><br><span class="line">    const Sub = function VueComponent(options) &#123;</span><br><span class="line">      this._init(options); //调用Vue初始化方法</span><br><span class="line">    &#125;;</span><br><span class="line">    Sub.cid = cid++;</span><br><span class="line">    Sub.prototype = Object.create(this.prototype); // 子类原型指向父类</span><br><span class="line">    Sub.prototype.constructor = Sub; //constructor指向自己</span><br><span class="line">    Sub.options = mergeOptions(this.options, extendOptions); //合并自己的options和父类的options</span><br><span class="line">    return Sub;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="32-写过自定义指令吗-原理是什么"><a href="#32-写过自定义指令吗-原理是什么" class="headerlink" title="32 写过自定义指令吗 原理是什么"></a>32 写过自定义指令吗 原理是什么</h4><p>指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。</p>
<p>自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span><br><span class="line"></span><br><span class="line">2. inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</span><br><span class="line"></span><br><span class="line">3. update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。</span><br><span class="line"></span><br><span class="line">4. componentUpdated：被绑定元素所在模板完成一次更新周期时调用。</span><br><span class="line"></span><br><span class="line">5. unbind：只调用一次，指令与元素解绑时调用。</span><br></pre></td></tr></table></figure>

<p><strong>「原理」</strong></p>
<p>1.在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性</p>
<p>2.通过 genDirectives 生成指令代码</p>
<p>3.在 patch 前将指令的钩子提取到 cbs 中,在 patch 过程中调用对应的钩子</p>
<p>4.当执行指令对应钩子函数时，调用对应指令定义的方法</p>
<h4 id="33-Vue-修饰符有哪些"><a href="#33-Vue-修饰符有哪些" class="headerlink" title="33 Vue 修饰符有哪些"></a>33 Vue 修饰符有哪些</h4><p><strong>「事件修饰符」</strong></p>
<ul>
<li>.stop 阻止事件继续传播</li>
<li>.prevent 阻止标签默认行为</li>
<li>.capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理</li>
<li>.self 只当在 event.target 是当前元素自身时触发处理函数</li>
<li>.once 事件将只会触发一次</li>
<li>.passive 告诉浏览器你不想阻止事件的默认行为</li>
</ul>
<p><strong>「v-model 的修饰符」</strong></p>
<ul>
<li>.lazy 通过这个修饰符，转变为在 change 事件再同步</li>
<li>.number 自动将用户的输入值转化为数值类型</li>
<li>.trim 自动过滤用户输入的首尾空格</li>
</ul>
<p><strong>「键盘事件的修饰符」</strong></p>
<ul>
<li>.enter</li>
<li>.tab</li>
<li>.delete (捕获“删除”和“退格”键)</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right</li>
</ul>
<p><strong>「系统修饰键」</strong></p>
<ul>
<li>.ctrl</li>
<li>.alt</li>
<li>.shift</li>
<li>.meta</li>
</ul>
<p><strong>「鼠标按钮修饰符」</strong></p>
<ul>
<li>.left</li>
<li>.right</li>
<li>.middle</li>
</ul>
<h4 id="34-Vue-模板编译原理"><a href="#34-Vue-模板编译原理" class="headerlink" title="34 Vue 模板编译原理"></a>34 Vue 模板编译原理</h4><p>Vue 的编译过程就是将 template 转化为 render 函数的过程 分为以下三</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">第一步是将 模板字符串 转换成 element ASTs（解析器）</span><br><span class="line">第二步是对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器）</span><br><span class="line">第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器）</span><br></pre></td></tr></table></figure>

<p>相关代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export function compileToFunctions(template) &#123;</span><br><span class="line">  // 我们需要把html字符串变成render函数</span><br><span class="line">  // 1.把html代码转成ast语法树  ast用来描述代码本身形成树结构 不仅可以描述html 也能描述css以及js语法</span><br><span class="line">  // 很多库都运用到了ast 比如 webpack babel eslint等等</span><br><span class="line">  let ast = parse(template);</span><br><span class="line">  // 2.优化静态节点</span><br><span class="line">  // 这个有兴趣的可以去看源码  不影响核心功能就不实现了</span><br><span class="line">  //   if (options.optimize !== false) &#123;</span><br><span class="line">  //     optimize(ast, options);</span><br><span class="line">  //   &#125;</span><br><span class="line"></span><br><span class="line">  // 3.通过ast 重新生成代码</span><br><span class="line">  // 我们最后生成的代码需要和render函数一样</span><br><span class="line">  // 类似_c(&#x27;div&#x27;,&#123;id:&quot;app&quot;&#125;,_c(&#x27;div&#x27;,undefined,_v(&quot;hello&quot;+_s(name)),_c(&#x27;span&#x27;,undefined,_v(&quot;world&quot;))))</span><br><span class="line">  // _c代表创建元素 _v代表创建文本 _s代表文Json.stringify--把对象解析成文本</span><br><span class="line">  let code = generate(ast);</span><br><span class="line">  //   使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值</span><br><span class="line">  let renderFn = new Function(`with(this)&#123;return $&#123;code&#125;&#125;`);</span><br><span class="line">  return renderFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="35-生命周期钩子是如何实现的"><a href="#35-生命周期钩子是如何实现的" class="headerlink" title="35 生命周期钩子是如何实现的"></a>35 生命周期钩子是如何实现的</h4><p>Vue 的生命周期钩子核心实现是利用发布订阅模式先把用户传入的的生命周期钩子订阅好（内部采用数组的方式存储）然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）</p>
<p>相关代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export function callHook(vm, hook) &#123;</span><br><span class="line">  // 依次执行生命周期对应的方法</span><br><span class="line">  const handlers = vm.$options[hook];</span><br><span class="line">  if (handlers) &#123;</span><br><span class="line">    for (let i = 0; i &lt; handlers.length; i++) &#123;</span><br><span class="line">      handlers[i].call(vm); //生命周期里面的this指向当前实例</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用的时候</span><br><span class="line">Vue.prototype._init = function (options) &#123;</span><br><span class="line">  const vm = this;</span><br><span class="line">  vm.$options = mergeOptions(vm.constructor.options, options);</span><br><span class="line">  callHook(vm, &quot;beforeCreate&quot;); //初始化数据之前</span><br><span class="line">  // 初始化状态</span><br><span class="line">  initState(vm);</span><br><span class="line">  callHook(vm, &quot;created&quot;); //初始化数据之后</span><br><span class="line">  if (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="36-函数式组件使用场景和原理"><a href="#36-函数式组件使用场景和原理" class="headerlink" title="36 函数式组件使用场景和原理"></a>36 函数式组件使用场景和原理</h4><p>函数式组件与普通组件的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.函数式组件需要在声明组件是指定 functional:true</span><br><span class="line">2.不需要实例化，所以没有this,this通过render函数的第二个参数context来代替</span><br><span class="line">3.没有生命周期钩子函数，不能使用计算属性，watch</span><br><span class="line">4.不能通过 $emit 对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件</span><br><span class="line">5.因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement</span><br><span class="line">6.函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都解析到 $attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)</span><br></pre></td></tr></table></figure>

<p>优点 1.由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件 2.函数式组件结构比较简单，代码结构更清晰</p>
<p>使用场景：</p>
<p>一个简单的展示组件，作为容器组件使用 比如 router-view 就是一个函数式组件</p>
<p>“高阶组件”——用于接收一个组件作为参数，返回一个被包装过的组件</p>
<p>相关代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (isTrue(Ctor.options.functional)) &#123;</span><br><span class="line">  // 带有functional的属性的就是函数式组件</span><br><span class="line">  return createFunctionalComponent(Ctor, propsData, data, context, children);</span><br><span class="line">&#125;</span><br><span class="line">const listeners = data.on;</span><br><span class="line">data.on = data.nativeOn;</span><br><span class="line">installComponentHooks(data); // 安装组件相关钩子 （函数式组件没有调用此方法，从而性能高于普通组件）</span><br></pre></td></tr></table></figure>

<h4 id="37-能说下-vue-router-中常用的路由模式实现原理吗"><a href="#37-能说下-vue-router-中常用的路由模式实现原理吗" class="headerlink" title="37 能说下 vue-router 中常用的路由模式实现原理吗"></a>37 能说下 vue-router 中常用的路由模式实现原理吗</h4><p><strong>「hash 模式」</strong></p>
<ol>
<li>location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</li>
<li>可以为 hash 的改变添加监听事件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;hashchange&quot;, funcRef, false);</span><br></pre></td></tr></table></figure>

<p>每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了</p>
<blockquote>
<p>特点：兼容性好但是不美观</p>
</blockquote>
<p><strong>「history 模式」</strong></p>
<p>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</p>
<p>这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。</p>
<blockquote>
<p>特点：虽然美观，但是刷新会出现 404 需要后端进行配置</p>
</blockquote>
<h4 id="38-diff-算法了解吗"><a href="#38-diff-算法了解吗" class="headerlink" title="38 diff 算法了解吗"></a>38 diff 算法了解吗</h4><p><img src="D:\资料\12---实训\案例\资料图\微信图片_20210524105813.jpg"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand hello" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2021/07/13/World/" title="World" itemprop="url">World</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="John Doe" target="_blank" itemprop="author">John Doe</a>
		
  <p class="article-time">
    <time datetime="2021-07-13T06:10:17.000Z" itemprop="datePublished"> Published 2021-07-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><strong>图片</strong><br><img src="https://img0.baidu.com/it/u=3101694723,748884042&fm=26&fmt=auto&gp=0.jpg" alt="Alt text"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2021/07/13/hello-world/" title="Hello World" itemprop="url">Hello World</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="John Doe" target="_blank" itemprop="author">John Doe</a>
		
  <p class="article-time">
    <time datetime="2021-07-13T06:04:10.330Z" itemprop="datePublished"> Published 2021-07-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2021 
		
		<a href="/about" target="_blank" title="John Doe">John Doe</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
